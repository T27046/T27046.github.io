<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
            overflow-y: hidden;
            height: 100%;
            width: 100%;
            position: fixed;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: #f8fafc;
            position: relative;
            overflow: hidden;
        }



        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 48px;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
        }

        .btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            border: none;
        }

        .btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
        }

        .btn.primary:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn.secondary {
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            border: 2px solid #667eea;
            backdrop-filter: blur(10px);
        }

        .btn.secondary:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        /* 主内容区域 */
        .main-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            position: relative;
            background: transparent;
            margin: 0;
            border-radius: 0;
            box-shadow: none;
        }

        /* 底部控制面板 */
        .bottom-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-top: 1px solid #e2e8f0;
            padding: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: center;
            max-height: 60vh;
            height: 60vh;
            overflow-y: auto;
            transition: height 0.3s ease, max-height 0.3s ease;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
        }

        .bottom-panel.collapsed {
            height: 60px;
            max-height: 60px;
            overflow: hidden;
        }

        .bottom-panel .panel {
            min-width: 300px;
            max-width: 400px;
            margin: 0;
            width: 100%;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .bottom-panel.collapsed .panel {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }

        /* 底部面板收起/展开按钮 */
        .bottom-panel-toggle {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid #ffffff;
            border-bottom: none;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            z-index: 1001;
            box-shadow: 0 -4px 15px rgba(102, 126, 234, 0.4);
            font-weight: 600;
            font-size: 12px;
        }

        .bottom-panel-toggle:hover {
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
            box-shadow: 0 -6px 20px rgba(102, 126, 234, 0.6);
            transform: translateX(-50%) translateY(-3px);
        }

        .bottom-panel-toggle:active {
            transform: translateX(-50%) translateY(0);
            box-shadow: 0 -2px 8px rgba(102, 126, 234, 0.3);
        }

        .bottom-panel.collapsed .bottom-panel-toggle svg {
            transform: rotate(180deg);
        }

        .bottom-panel-toggle svg {
            transition: transform 0.3s ease;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
        }

        /* 收起状态下的按钮样式 */
        .bottom-panel.collapsed .bottom-panel-toggle {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            box-shadow: 0 -4px 15px rgba(76, 175, 80, 0.4);
        }

        .bottom-panel.collapsed .bottom-panel-toggle:hover {
            background: linear-gradient(135deg, #43A047 0%, #3d8b40 100%);
            box-shadow: 0 -6px 20px rgba(76, 175, 80, 0.6);
        }

        /* 侧边栏 */
        .sidebar {
            width: 100%;
            background: #ffffff;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            overflow-x: auto;
            overflow-y: hidden;
            height: auto;
            max-height: 45vh;
            transition: max-height 0.3s ease;
        }

        .sidebar.collapsed {
            max-height: 0;
            overflow: hidden;
        }

        .panel-container {
            display: flex;
            min-width: max-content;
            padding: 16px 20px;
            gap: 16px;
        }

        .panel {
            background: #ffffff;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
            border: 1px solid #f1f5f9;
            min-width: 320px;
            flex-shrink: 0;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .panel:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        .panel h3 {
            margin-bottom: 16px;
            color: #2c3e50;
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .data-info p {
            margin: 8px 0;
            color: #8e8e93;
            font-size: 14px;
        }

        .highlight {
            color: #ff3b30;
            font-weight: 600;
        }

        .route-form {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .search-select-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 16px;
            background: #f8fafc;
        }
        
        .searchable-select-container {
            position: relative;
        }
        
        .searchable-select {
            position: relative;
        }
        
        .searchable-select-input {
            width: 100%;
            padding: 16px 20px;
            border: 2px solid #e8e8e8;
            border-radius: 15px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.95);
            color: #2c3e50;
            transition: all 0.3s ease;
            background-image: url("data:image/svg+xml;charset=US-ASCII,<svg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'><path d='M5 7.5L10 12.5L15 7.5' stroke='%23667eea' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg>");
            background-repeat: no-repeat;

        /* 图例样式 */
        .legend-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 300px;
            max-height: 70vh;
            overflow-y: auto;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .legend-container.collapsed {
            max-height: 40px;
            overflow: hidden;
            padding: 8px 16px;
        }

        .legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            cursor: pointer;
        }

        .legend-title {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }

        .legend-toggle {
            background: none;
            border: none;
            font-size: 18px;
            color: #667eea;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .legend-toggle:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .legend-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }

        .legend-item:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .legend-info {
            flex: 1;
            min-width: 0;
        }

        .legend-line-name {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 2px;
        }

        .legend-line-details {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
        }

        .legend-line-type {
            display: inline-block;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            margin-right: 6px;
        }

        .legend-stations {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }

        /* 图例缩放适配 */
        @media (max-width: 768px) {
            .legend-container {
                top: 10px;
                right: 10px;
                max-width: 250px;
            }
        }
            background-position: right 16px center;
            background-size: 16px;
            backdrop-filter: blur(10px);
        }
        
        .searchable-select-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            background-color: white;
        }
        
        .searchable-select-input:hover {
            border-color: #b8c2cc;
        }
        
        .searchable-select-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #c6c6c8;
            border-top: none;
            border-radius: 0 0 10px 10px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: none;
        }
        
        .searchable-select-option {
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #f2f2f7;
            transition: background-color 0.2s ease;
        }
        
        .searchable-select-option:hover {
            background-color: #f2f2f7;
        }
        
        .searchable-select-option:last-child {
            border-bottom: none;
        }

        .station-select {
            width: 100%;
            padding: 12px;
            border: 1px solid #c6c6c8;
            border-radius: 10px;
            font-size: 16px;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,<svg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'><path d='M5 7.5L10 12.5L15 7.5' stroke='%238e8e93' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg>");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            margin-bottom: 8px;
        }

        .station-select:focus {
            outline: none;
            border-color: #007AFF;
        }
        
        .strategy-select {
            width: 100%;
            padding: 12px;
            border: 1px solid #c6c6c8;
            border-radius: 10px;
            font-size: 16px;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,<svg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'><path d='M5 7.5L10 12.5L15 7.5' stroke='%238e8e93' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg>");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            margin-bottom: 8px;
        }
        
        .strategy-select:focus {
            outline: none;
            border-color: #007AFF;
        }
        
        .route-options {
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .route-options label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
            font-size: 14px;
        }



        .route-info, .transfer-info {
            margin-top: 12px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.4;
            color: #8e8e93;
        }

        .transfer-step {
            background: #f2f2f7;
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            border-left: 4px solid #007AFF;
        }

        .transfer-step .line-name {
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .transfer-step .stations {
            color: #8e8e93;
            font-size: 13px;
        }

        /* 地图容器 */
        .map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #f8f9fa;
            touch-action: none;
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
        }

        #mapCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }

        #mapCanvas:active {
            cursor: grabbing;
        }

        .map-controls {
            position: absolute;
            top: 24px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
        }

        .map-btn {
            width: 56px;
            height: 56px;
            border: none;
            border-radius: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            cursor: pointer;
            font-size: 22px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            color: white;
            touch-action: manipulation;
            position: relative;
            overflow: hidden;
        }

        .map-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
        }

        .map-btn:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        /* 站名标签样式 */
        .station-label {
            position: absolute;
            background: none;
            padding: 0;
            border: none;
            font-size: 12px;
            font-weight: 200;
            color: #000000; /* 黑色文字 */
            white-space: nowrap;
            box-shadow: none;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.5), 0 0 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: none;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -100%);
        }
        
        /* 双语站名样式 */
        .station-name-chinese {
            background: none;
            padding: 0;
            border: none;
            font-size: 11px;
            font-weight: 150;
            color: #000000; /* 黑色文字 */
            white-space: nowrap;
            box-shadow: none;
            /*text-shadow: 0 0 6px rgba(255, 255, 255, 0.8), 0 0 12px rgba(255, 255, 255, 0.6);*/
            backdrop-filter: none;
            margin-bottom: 1px;
        }
        
        .station-name-english {
            background: none;
            padding: 0;
            border: none;
            font-size: 9px;
            font-weight: 50;
            color: #333333; /* 深灰色 */
            white-space: nowrap;
            box-shadow: none;
            /*text-shadow: 0 0 4px rgba(255, 255, 255, 0.8), 0 0 8px rgba(255, 255, 255, 0.6); */
            backdrop-filter: none;
        }
        
        /* 换乘信息样式 */
        .station-transfer-info {
            margin-top: 2px;
            padding: 2px 4px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 3px;
            color: #000000; /* 黑色文字 */
            /*text-shadow: 0 0 4px rgba(255, 255, 255, 0.8), 0 0 8px rgba(255, 255, 255, 0.6);*/
            border: 1px solid #e0e0e0;
            font-size: 8px;
            line-height: 1.2;
        }
        
        .transfer-lines {
            color: #007AFF;
            font-weight: bold;
        }
        
        .transfer-platforms {
            color: #666666;
            font-size: 7px;
        }



        /* 移动端优化 - 高德地图风格 */
        @media (max-width: 768px) {
            
            .btn {
                padding: 5px 8px;
                font-size: 11px;
                min-height: 30px;
                border-radius: 6px;
            }
            
            .btn.primary {
                background: linear-gradient(135deg, #1E90FF, #007AFF);
            }
            
            .btn.secondary {
                background: rgba(255, 255, 255, 0.9);
                color: #007AFF;
                border: 1px solid rgba(30, 144, 255, 0.3);
            }
            
            .sidebar {
                max-height: 35vh;
                background: rgba(255, 255, 255, 0.98);
                backdrop-filter: blur(20px);
                border-bottom: 1px solid rgba(30, 144, 255, 0.3);
            }
            
            .panel-container {
                padding: 6px 10px;
                gap: 6px;
            }
            
            .panel {
                padding: 10px;
                min-width: 260px;
                background: rgba(255, 255, 255, 0.95);
                border: 1px solid rgba(30, 144, 255, 0.15);
                box-shadow: 0 4px 12px rgba(30, 144, 255, 0.1);
            }
            
            .panel h3 {
                font-size: 13px;
                margin-bottom: 6px;
                color: #007AFF;
            }
            
            .station-select {
                padding: 8px;
                font-size: 12px;
                border: 1px solid rgba(30, 144, 255, 0.2);
            }
            
            .map-container {
                background: #f8f9fa;
            }
            
            .map-btn {
                width: 44px;
                height: 44px;
                font-size: 18px;
                background: linear-gradient(135deg, #1E90FF, #007AFF);
                box-shadow: 0 4px 12px rgba(30, 144, 255, 0.3);
            }
            
            .map-controls {
                top: 16px;
                right: 12px;
                gap: 4px;
            }
            
            .station-label {
                background: none;
                border: none;
                font-size: 9px;
                padding: 0;
            }
        }

        /* 小屏幕手机优化 - 高德地图风格 */
        @media (max-width: 480px) {
            
            .btn {
                padding: 4px 6px;
                font-size: 10px;
                min-height: 28px;
                border-radius: 4px;
            }
            
            .sidebar {
                max-height: 28vh;
            }
            
            .panel-container {
                padding: 4px 8px;
                gap: 4px;
            }
            
            .panel {
                padding: 8px;
                min-width: 220px;
            }
            
            .panel h3 {
                font-size: 12px;
                margin-bottom: 4px;
            }
            
            .station-select {
                padding: 6px;
                font-size: 11px;
            }
            
            .map-container {
                height: 72vh;
            }
            
            .map-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            .map-controls {
                top: 12px;
                right: 8px;
            }
            
            .station-label {
                font-size: 8px;
                padding: 0;
                background: none;
                border: none;
                box-shadow: none;
                text-shadow: none;
            }
            
            .notification {
                top: 10px;
                right: 10px;
                padding: 0.8rem 1.2rem;
                font-size: 12px;
            }
        }

        /* 通知样式 */
        .notification {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 20px 24px;
            border-radius: 16px;
            color: white;
            z-index: 10000;
            animation: slideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 12px 40px rgba(0,0,0,0.2);
            font-weight: 600;
            font-size: 15px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 400px;
        }

        .notification.success {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.9) 0%, rgba(46, 204, 113, 0.9) 100%);
        }

        .notification.error {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.9) 0%, rgba(192, 57, 43, 0.9) 100%);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">

        <!-- 主内容区域 -->
        <main class="main-content">
            <!-- 地图区域 -->
            <div class="map-container">
                <canvas id="mapCanvas"></canvas>
                <!-- 图例容器 -->
                <div class="legend-container" id="legendContainer">
                    <div class="legend-header" onclick="mapRenderer.toggleLegend()">
                        <h3 class="legend-title">线路图例</h3>
                        <button class="legend-toggle" title="展开/收起图例">▼</button>
                    </div>
                    <div class="legend-content" id="legendContent">
                        <!-- 图例内容将通过JavaScript动态生成 -->
                    </div>
                </div>
                <div class="map-controls">
                    <button id="zoomIn" class="map-btn" title="放大">+</button>
                    <button id="zoomOut" class="map-btn" title="缩小">-</button>
                    <button id="resetView" class="map-btn" title="重置视图">↺</button>
                    <button id="saveImage" class="map-btn" title="保存图片">保存</button>
                </div>
            </div>

            <!-- 底部控制面板 -->
            <div class="bottom-panel">
                <!-- 收起/展开按钮 -->
                <div class="bottom-panel-toggle" onclick="utils.toggleBottomPanel()">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M5 7.5L10 12.5L15 7.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                
                <div class="panel">
                    <h3>站点选择</h3>
                    <div class="route-form">
                        <!-- 可搜索下拉框组合 -->
                        <div class="search-select-group">
                            <div class="searchable-select-container">
                                <div class="searchable-select" data-for="startStation">
                                    <input type="text" class="searchable-select-input" placeholder="搜索起点站...">
                                    <div class="searchable-select-options" id="startStationOptions"></div>
                                </div>
                                <select id="startStation" class="station-select" style="display: none;">
                                    <option value="">选择起点站</option>
                                </select>
                            </div>
                            
                            <div class="searchable-select-container">
                                <div class="searchable-select" data-for="endStation">
                                    <input type="text" class="searchable-select-input" placeholder="搜索终点站...">
                                    <div class="searchable-select-options" id="endStationOptions"></div>
                                </div>
                                <select id="endStation" class="station-select" style="display: none;">
                                    <option value="">选择终点站</option>
                                </select>
                            </div>
                        </div>
                        
                        <button id="calculateRoute" class="btn primary">计算路径</button>
                    </div>
                    <div id="routeInfo" class="route-info">
                        <p>请选择起点和终点站进行路径规划</p>
                    </div>
                </div>
                
                <div class="panel">
                    <h3>换乘信息</h3>
                    <div id="transferInfo" class="transfer-info">
                        <p>路径规划完成后显示换乘信息</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // 应用状态
        const appState = {
            canvas: null,
            ctx: null,
            stations: [],
            lines: [],
            graph: null,
            mapScale: 1,
            mapOffset: { x: 0, y: 0 },
            isDragging: false,
            lastMousePos: { x: 0, y: 0 },
            isPinching: false,
            lastTouchPos: { x: 0, y: 0 },
            lastTouchDistance: 0,
            stationLabels: [],
            // 新增：节点转折点管理（像站点一样存储）
            nodes: []
        };

        // 工具函数
        const utils = {
            showNotification(message, type = 'success') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 3000);
            },

            // 移动端侧边栏折叠功能
        toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('collapsed');
        },

        // 检测是否为移动设备（基于显示区域尺寸）
        isMobileDevice() {
            return window.innerWidth <= 768;
        },

        // 底部面板收起/展开功能
        toggleBottomPanel() {
            const bottomPanel = document.querySelector('.bottom-panel');
            const toggleButton = document.querySelector('.bottom-panel-toggle');
            const isCollapsed = bottomPanel.classList.toggle('collapsed');
            
            // 更新按钮提示文本
            if (isCollapsed) {
                toggleButton.setAttribute('title', '展开面板');
                toggleButton.setAttribute('aria-label', '展开底部面板');
                // 添加收起状态指示
                this.showNotification('底部面板已收起', 'success');
            } else {
                toggleButton.setAttribute('title', '收起面板');
                toggleButton.setAttribute('aria-label', '收起底部面板');
                // 添加展开状态指示
                this.showNotification('底部面板已展开', 'success');
            }
        },

            parseCSV(csvText) {
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',').map(h => h.trim());
                const data = [];
                
                for (let i = 1; i < lines.length; i++) {
                    // 改进的CSV解析，处理包含逗号的引号字段
                    const line = lines[i];
                    const values = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let j = 0; j < line.length; j++) {
                        const char = line[j];
                        
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            values.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    values.push(current.trim()); // 添加最后一个字段
                    
                    // 移除字段值中的引号
                    const cleanedValues = values.map(v => v.replace(/^"/, '').replace(/"$/, ''));
                    
                    if (cleanedValues.length === headers.length) {
                        const item = {};
                        headers.forEach((header, index) => {
                            item[header] = cleanedValues[index];
                        });
                        data.push(item);
                    }
                }
                return data;
            },

            parseJSON(jsonText) {
                try {
                    return JSON.parse(jsonText);
                } catch (error) {
                    throw new Error('JSON格式错误');
                }
            },

            calculateDistance(x1, y1, x2, y2) {
                // 使用欧几里得距离公式计算两点之间的距离（单位：米）
                const dx = x2 - x1;
                const dy = y2 - y1;
                return Math.sqrt(dx * dx + dy * dy);
            }
        };

        // 数据处理函数
        const dataProcessor = {
            parseCSVData(csvText) {
                const data = utils.parseCSV(csvText);
                
                // 按线路分组站点数据
                const linesMap = new Map();
                
                data.forEach(item => {
                    const lineId = item.line || '1';
                    const lineName = item.lineName || `线路${lineId}`;
                    
                    if (!linesMap.has(lineId)) {
                        linesMap.set(lineId, {
                            id: lineId,
                            name: lineName,
                            color: this.getLineColor(lineId),
                            stations: []
                        });
                    }
                    
                    const station = {
                        name: item.name || item.station || '',
                        englishName: item.englishName || item.english_name || item.name || '',
                        latitude: parseFloat(item.latitude || item.lat || 0),
                        longitude: parseFloat(item.longitude || item.lng || item.lon || 0),
                        line: lineId,
                        sequence: parseInt(item.sequence) || 0,
                        transfer: item.transfer === 'true' || item.transfer === 'TRUE' || item.transfer === true,
                        transferLines: item.transferLines ? item.transferLines.split(',').map(line => line.trim()) : [],
                        transferPlatforms: item.transferPlatforms ? item.transferPlatforms.split(',').map(platform => platform.trim()) : []
                    };
                    
                    if (station.name && !isNaN(station.latitude) && !isNaN(station.longitude)) {
                        linesMap.get(lineId).stations.push(station);
                    }
                });
                
                // 对每条线路的站点按sequence排序
                linesMap.forEach(line => {
                    line.stations.sort((a, b) => a.sequence - b.sequence);
                });
                
                return {
                    lines: Array.from(linesMap.values()),
                    stations: Array.from(linesMap.values()).flatMap(line => line.stations)
                };
            },
            
            getLineColor(lineId) {
                const colors = {
                    '1': '#FF0000',        // 红色
                    '2': '#0000FF',        // 蓝色
                    '3': '#00FF00',        // 绿色
                    '4': '#FFA500',        // 橙色
                    '5': '#800080',        // 紫色
                    '6': '#FFC0CB',        // 粉色
                    '7': '#A52A2A',        // 棕色
                    '8': '#808080',        // 灰色
                    '9': '#FFFF00',        // 黄色
                    '10': '#00FFFF',       // 青色
                    'N1': '#E3002B',       // 深红色（来自数据文件）
                    'N2': '#8A2BE2',      // 蓝紫色
                    'N3': '#FF4500',      // 橙红色
                    'K1': '#53c700',      // 绿色（来自数据文件）
                    'K2': '#005eff',      // 蓝色（来自数据文件）
                    '近西南线': '#ffd500', // 金色（来自数据文件）
                    '北桥线': '#ff8fa4',   // 粉色（来自数据文件）
                    'S1': '#00c3ff',      // 天蓝色（来自数据文件）
                    'S2': '#00ffaa',      // 青绿色（来自数据文件）
                    'S3': '#fcba77',      // 浅橙色（来自数据文件）
                    'S4': '#ff5900',      // 橙色（来自数据文件）
                    'S5': '#b7ff00',      // 黄绿色（来自数据文件）
                    'S6': '#b7ff00'       // 黄绿色（来自数据文件）
                };
                return colors[lineId] || '#000000'; // 默认黑色
            },

            // 节点数据结构
            Node: class {
                constructor(id, name, X, Y, type = 'turn') {
                    this.id = id;
                    this.name = name;
                    this.X = X;
                    this.Y = Y;
                    this.type = type; // 'turn': 转折点, 'station': 站点
                    this.connectedLines = [];
                }
            },

            // 解析节点数据（适配您的CSV格式：x,y,line,stn1,stn2）
            parseNodeData(nodeData) {
                const nodes = [];
                const rows = nodeData.trim().split('\n');
                
                // 跳过空行
                const nonEmptyRows = rows.filter(row => row.trim());
                if (nonEmptyRows.length < 2) return nodes; // 至少需要标题行和一行数据
                
                const headers = nonEmptyRows[0].split(',').map(h => h.trim());
                
                for (let i = 1; i < nonEmptyRows.length; i++) {
                    const row = nonEmptyRows[i].trim();
                    if (!row) continue;
                    
                    const values = row.split(',').map(v => v.trim());
                    
                    if (values.length === headers.length) {
                        const nodeInfo = {};
                        headers.forEach((header, index) => {
                            nodeInfo[header] = values[index];
                        });
                        
                        // 根据您的CSV格式创建节点（作为特殊站点）
                        const node = {
                            id: `node_${nodes.length + 1}`,
                            name: `${nodeInfo.stn1}_${nodeInfo.stn2}_节点`,
                            X: parseFloat(nodeInfo.x),
                            Y: parseFloat(nodeInfo.y),
                            type: 'node', // 特殊类型：节点
                            line: nodeInfo.line,
                            stn1: nodeInfo.stn1,
                            stn2: nodeInfo.stn2,
                            englishName: `${nodeInfo.stn1}_${nodeInfo.stn2}_Node`,
                            lineName: nodeInfo.line
                        };
                        
                        nodes.push(node);
                    }
                }
                
                return nodes;
            },

            parseJSONData(jsonText) {
                const data = utils.parseJSON(jsonText);
                if (Array.isArray(data)) {
                    return data.map(item => ({
                        name: item.name || item.station || '',
                        latitude: parseFloat(item.latitude || item.lat || 0),
                        longitude: parseFloat(item.longitude || item.lng || item.lon || 0),
                        line: item.line || '1',
                        lineName: item.lineName || `线路${item.line || '1'}`
                    })).filter(station => station.name && !isNaN(station.latitude) && !isNaN(station.longitude));
                }
                return [];
            },

            groupStationsByLine(stations) {
                const linesMap = new Map();
                
                stations.forEach(station => {
                    if (!linesMap.has(station.line)) {
                        linesMap.set(station.line, {
                            id: station.line,
                            name: station.lineName,
                            color: this.getLineColor(station.line),
                            stations: []
                        });
                    }
                    linesMap.get(station.line).stations.push(station);
                });
                
                // 按站点顺序排序，支持sequenceList
                linesMap.forEach(line => {
                    line.stations.sort((a, b) => {
                        // 优先使用sequenceList中对应线路的顺序
                        const aSeqList = a.sequenceList || [a.sequence];
                        const bSeqList = b.sequenceList || [b.sequence];
                        
                        // 使用第一个有效的序列值进行排序
                        const aSeq = aSeqList.length > 0 ? aSeqList[0] : a.sequence;
                        const bSeq = bSeqList.length > 0 ? bSeqList[0] : b.sequence;
                        
                        return aSeq - bSeq;
                    });
                });
                
                return Array.from(linesMap.values());
            },



            parseLineData(lineData) {
                const lines = [];
                const rows = lineData.trim().split('\n');
                const headers = rows[0].split(',');
                
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    if (!row.trim()) continue;
                    
                    const values = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let j = 0; j < row.length; j++) {
                        const char = row[j];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            values.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    values.push(current.trim());
                    
                    if (values.length === headers.length) {
                        const line = {};
                        headers.forEach((header, index) => {
                            line[header] = values[index];
                        });
                        lines.push(line);
                    }
                }
                
                return lines;
            },

            parseStationData(stationData) {
                const stations = [];
                const rows = stationData.trim().split('\n');
                const headers = rows[0].split(',');
                
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    if (!row.trim()) continue;
                    
                    const values = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let j = 0; j < row.length; j++) {
                        const char = row[j];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            values.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    values.push(current.trim());
                    
                    if (values.length === headers.length) {
                        const station = {};
                        headers.forEach((header, index) => {
                            station[header] = values[index];
                        });
                        stations.push(station);
                    }
                }
                
                return stations;
            },

            combineLineAndStationData(linesData, stationsData) {
                const lines = [];
                const stations = [];
                
                // 处理每条线路
                linesData.forEach((lineInfo, index) => {
                    // 生成默认的线路ID和名称（对于没有lineId和lineName的步行路线路）
                    const lineId = lineInfo.lineId || `W${index + 1}`;
                    const lineName = lineInfo.lineName || '步行路';
                    
                    const line = {
                        id: lineId,
                        name: lineName,
                        color: lineInfo.color,
                        isExpress: lineInfo.isExpress === 'true',
                        lineType: lineInfo.lineType || 'subway', // 默认地铁类型
                        stations: [],
                        branches: {} // 存储支线信息
                    };
                    
                    // 解析站点序列（支持支线格式）
                    if (lineInfo.stationSequence) {
                        // 检查是否包含支线分隔符
                        if (lineInfo.stationSequence.includes('|')) {
                            // 解析支线格式
                            const parts = lineInfo.stationSequence.split('|');
                            
                            // 主线路部分（第一个部分）
                            const mainLinePart = parts[0].trim();
                            this.parseStationSequence(mainLinePart, line, stations, stationsData, 'main');
                            
                            // 支线部分（后续部分）
                            for (let i = 1; i < parts.length; i++) {
                                const branchPart = parts[i].trim();
                                if (branchPart.includes(':')) {
                                    const [branchName, branchStations] = branchPart.split(':');
                                    if (branchName && branchStations) {
                                        const branchLine = {
                                            id: `${lineId}_${branchName.trim()}`,
                                            name: `${lineName} ${branchName.trim()}`,
                                            color: lineInfo.color,
                                            isExpress: lineInfo.isExpress === 'true',
                                            lineType: lineInfo.lineType || 'subway',
                                            stations: [],
                                            branchOf: lineId,
                                            branchName: branchName.trim()
                                        };
                                        
                                        this.parseStationSequence(branchStations.trim(), branchLine, stations, stationsData, branchName.trim());
                                        
                                        // 将支线添加到主线路的branches对象中
                                        if (!line.branches) line.branches = {};
                                        line.branches[branchName.trim()] = branchLine;
                                        
                                        // 将支线添加到线路列表中
                                        lines.push(branchLine);
                                    }
                                }
                            }
                        } else {
                            // 传统格式（无支线）
                            this.parseStationSequence(lineInfo.stationSequence, line, stations, stationsData, 'main');
                        }
                    }
                    
                    // 按序列号排序站点
                    line.stations.sort((a, b) => a.sequence - b.sequence);
                    lines.push(line);
                });
                
                return { lines, stations };
            },
            
            // 解析站点序列的辅助函数
            parseStationSequence(sequenceString, line, stations, stationsData, branchType) {
                const stationPairs = sequenceString.split(',');
                stationPairs.forEach(pair => {
                    const [stationName, sequence] = pair.split(':');
                    if (stationName && sequence) {
                        // 查找站点信息
                        const stationInfo = stationsData.find(s => s.name === stationName.trim());
                        if (stationInfo) {
                            const station = {
                                name: stationInfo.name,
                                englishName: stationInfo.englishName,
                                X: parseFloat(stationInfo.X),
                                Y: parseFloat(stationInfo.Y),
                                line: line.id,
                                lineName: line.name,
                                sequence: parseInt(sequence),
                                transfer: stationInfo.transfer === 'true',
                                transferLines: stationInfo.transferLines ? stationInfo.transferLines.split(',') : [],
                                transferPlatforms: stationInfo.transferPlatforms ? stationInfo.transferPlatforms.split(',') : [],
                                isMajor: stationInfo.isMajor === 'true',
                                management: stationInfo.management || '',
                                branch: branchType // 标记所属支线
                            };
                            line.stations.push(station);
                            stations.push(station);
                        }
                    }
                });
            },

            // 将节点插入到线路站点序列中
            insertNodesIntoLineSequences(lines, nodes) {
                nodes.forEach(node => {
                    // 找到节点所属的线路
                    const targetLine = lines.find(line => line.id === node.line);
                    if (!targetLine) return;
                    
                    // 找到节点前后的站点
                    const stn1Index = targetLine.stations.findIndex(station => station.name === node.stn1);
                    const stn2Index = targetLine.stations.findIndex(station => station.name === node.stn2);
                    
                    // 确保两个站点都存在且相邻
                    if (stn1Index !== -1 && stn2Index !== -1 && Math.abs(stn1Index - stn2Index) === 1) {
                        // 确定插入位置（在stn1和stn2之间）
                        const insertIndex = Math.max(stn1Index, stn2Index);
                        
                        // 计算插入节点的序列号（取前后站点的平均值）
                        const prevStation = targetLine.stations[insertIndex - 1];
                        const nextStation = targetLine.stations[insertIndex];
                        const nodeSequence = (prevStation.sequence + nextStation.sequence) / 2;
                        
                        // 创建节点站点对象
                        const nodeStation = {
                            name: node.name,
                            englishName: node.englishName,
                            X: node.X,
                            Y: node.Y,
                            line: node.line,
                            lineName: node.lineName,
                            sequence: nodeSequence,
                            transfer: false,
                            transferLines: [],
                            transferPlatforms: [],
                            isMajor: false,
                            management: '',
                            type: 'node' // 标记为节点类型
                        };
                        
                        // 插入节点到线路站点序列
                        targetLine.stations.splice(insertIndex, 0, nodeStation);
                        
                        console.log(`在线路 ${node.line} 的 ${node.stn1} 和 ${node.stn2} 之间插入节点 ${node.name}`);
                    }
                });
                
                // 重新排序所有线路的站点
                lines.forEach(line => {
                    line.stations.sort((a, b) => a.sequence - b.sequence);
                });
                
                return lines;
            }
        };

        // 路径规划算法
        const routePlanner = {
            buildGraph(lines) {
                const graph = {};
                
                // 首先收集所有站点（包含步行路线路）
                const allStations = [];
                lines.forEach(line => {
                    allStations.push(...line.stations);
                });
                
                // 连接同一条线路上的相邻站点（包含步行路线路）
                // 只连接至少包含2个站点的线路，确保用户能够乘坐该线路到另一站
                lines.forEach(line => {
                    // 如果线路站点数量少于2个，跳过该线路（用户无法乘坐该线路到另一站）
                    if (line.stations.length < 2) {
                        return;
                    }
                    
                    const stations = line.stations;
                    for (let i = 0; i < stations.length - 1; i++) {
                        const stationA = stations[i];
                        const stationB = stations[i + 1];
                        
                        // 使用唯一标识符作为节点名称
                        const nodeA = `${stationA.name}_${stationA.line}`;
                        const nodeB = `${stationB.name}_${stationB.line}`;
                        
                        const distance = utils.calculateDistance(
                            stationA.X, stationA.Y,
                            stationB.X, stationB.Y
                        );
                        
                        if (!graph[nodeA]) graph[nodeA] = {};
                        if (!graph[nodeB]) graph[nodeB] = {};
                        
                        graph[nodeA][nodeB] = distance;
                        graph[nodeB][nodeA] = distance;
                    }
                });
                
                // 连接换乘站（允许步行路线路与地铁线路之间的换乘）
                allStations.forEach(stationA => {
                    // 对于步行路线路，允许与地铁线路换乘，即使站点本身不支持换乘
                    const lineAInfo = lines.find(l => l.id === stationA.line);
                    const isWalkingLineA = lineAInfo && lineAInfo.lineType === 'walking';
                    
                    // 如果站点支持换乘，或者是步行路线路的站点，则允许换乘连接
                    if (stationA.transfer || isWalkingLineA) {
                        const nodeA = `${stationA.name}_${stationA.line}`;
                        
                        // 查找同一位置的其他站点
                        allStations.forEach(stationB => {
                            if (stationB.name === stationA.name && stationB.line !== stationA.line) {
                                // 查找线路B信息
                                const lineBInfo = lines.find(l => l.id === stationB.line);
                                const isWalkingLineB = lineBInfo && lineBInfo.lineType === 'walking';
                                
                                // 对于步行路线路与地铁线路之间的换乘，允许连接
                                // 或者两个站点都支持换乘
                                if ((stationB.transfer || isWalkingLineB) && lineAInfo && lineBInfo && 
                                    !(lineAInfo.isExpress && lineBInfo.isExpress)) {
                                    
                                    const nodeB = `${stationB.name}_${stationB.line}`;
                                    
                                    if (!graph[nodeA]) graph[nodeA] = {};
                                    if (!graph[nodeB]) graph[nodeB] = {};
                                    
                                    // 换乘距离设为0（同一位置）
                                    graph[nodeA][nodeB] = 0;
                                    graph[nodeB][nodeA] = 0;
                                }
                            }
                        });
                    }
                });
                
                return graph;
            },

            dijkstra(graph, start, end) {
                const distances = {};
                const previous = {};
                const nodes = new Set();
                
                // 处理起点和终点，如果它们不包含线路信息，需要找到对应的节点
                let startNode = start;
                let endNode = end;
                
                if (!start.includes('_')) {
                    const matchingNodes = Object.keys(graph).filter(node => node.startsWith(start + '_'));
                    if (matchingNodes.length > 0) {
                        startNode = matchingNodes[0];
                    }
                }
                
                if (!end.includes('_')) {
                    const matchingNodes = Object.keys(graph).filter(node => node.startsWith(end + '_'));
                    if (matchingNodes.length > 0) {
                        endNode = matchingNodes[0];
                    }
                }
                
                // 初始化
                for (let node in graph) {
                    distances[node] = Infinity;
                    previous[node] = null;
                    nodes.add(node);
                }
                distances[startNode] = 0;
                
                while (nodes.size > 0) {
                    let smallest = null;
                    for (let node of nodes) {
                        if (smallest === null || distances[node] < distances[smallest]) {
                            smallest = node;
                        }
                    }
                    
                    if (smallest === endNode) break;
                    
                    nodes.delete(smallest);
                    
                    for (let neighbor in graph[smallest]) {
                        const edgeWeight = graph[smallest][neighbor];
                        const alt = distances[smallest] + edgeWeight;
                        if (alt < distances[neighbor]) {
                            distances[neighbor] = alt;
                            previous[neighbor] = smallest;
                        }
                    }
                }
                
                // 构建路径
                const path = [];
                let current = endNode;
                while (current !== null) {
                    path.unshift(current);
                    current = previous[current];
                }
                
                return {
                    distance: distances[endNode],
                    path: path
                };
            },

            analyzeTransfers(route, lines) {
                const transfers = [];
                let currentLine = null;
                let currentSegment = [];
                
                route.path.forEach((station, index) => {
                    // 查找站点信息，考虑站点名称可能重复的情况
                    const stationInfo = appState.stations.find(s => {
                        // 如果路径中的站点名称包含线路信息（如"建国门站_1"），则精确匹配
                        if (station.includes('_')) {
                            return s.name === station.split('_')[0] && s.line === station.split('_')[1];
                        }
                        // 否则按名称匹配
                        return s.name === station;
                    });
                    
                    if (!stationInfo) return;
                    
                    // 查找线路信息
                    const lineInfo = lines.find(l => l.id === stationInfo.line);
                    
                    // 如果是步行路线路，显示为步行换乘
                    if (lineInfo && lineInfo.lineType === 'walking') {
                        if (currentSegment.length > 1) { // 只添加至少包含2个站点的线路段
                            transfers.push({
                                line: currentLine,
                                lineName: lines.find(l => l.id === currentLine)?.name || `线路${currentLine}`,
                                stations: [...currentSegment]
                            });
                        }
                        // 添加步行路线路换乘
                        transfers.push({
                            line: stationInfo.line,
                            lineName: "步行路",
                            stations: [station]
                        });
                        currentLine = null;
                        currentSegment = [];
                        return;
                    }
                    
                    if (stationInfo.line !== currentLine) {
                        if (currentSegment.length > 1) { // 只添加至少包含2个站点的线路段
                            transfers.push({
                                line: currentLine,
                                lineName: lines.find(l => l.id === currentLine)?.name || `线路${currentLine}`,
                                stations: [...currentSegment]
                            });
                        }
                        currentLine = stationInfo.line;
                        currentSegment = [station];
                    } else {
                        currentSegment.push(station);
                    }
                });
                
                if (currentSegment.length > 1) { // 只添加至少包含2个站点的线路段
                    transfers.push({
                        line: currentLine,
                        lineName: lines.find(l => l.id === currentLine)?.name || `线路${currentLine}`,
                        stations: currentSegment
                    });
                }
                
                return transfers;
            }
        };

        // 地图渲染函数
        const mapRenderer = {
            init() {
                appState.canvas = document.getElementById('mapCanvas');
                appState.ctx = appState.canvas.getContext('2d');
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // 绑定事件（使用箭头函数保持正确的this上下文）
                appState.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                appState.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                appState.canvas.addEventListener('mouseup', () => this.handleMouseUp());
                appState.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                
                // 触摸事件支持
                appState.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                appState.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                appState.canvas.addEventListener('touchend', () => this.handleTouchEnd());
            },

            resizeCanvas() {
                appState.canvas.width = appState.canvas.clientWidth;
                appState.canvas.height = appState.canvas.clientHeight;
                this.render();
            },

            handleMouseDown(e) {
                appState.isDragging = true;
                appState.lastMousePos = { x: e.clientX, y: e.clientY };
                appState.canvas.style.cursor = 'grabbing';
            },

            handleMouseMove(e) {
                if (appState.isDragging) {
                    const deltaX = e.clientX - appState.lastMousePos.x;
                    const deltaY = e.clientY - appState.lastMousePos.y;
                    
                    // 根据地图缩放比例调整移动速度（使用平方根函数实现更平滑的调整）
                    const speedFactor = Math.sqrt(1 / appState.mapScale);
                    appState.mapOffset.x += deltaX * speedFactor;
                    appState.mapOffset.y += deltaY * speedFactor;
                    
                    appState.lastMousePos = { x: e.clientX, y: e.clientY };
                    this.render();
                }
            },

            handleMouseUp() {
                appState.isDragging = false;
                appState.canvas.style.cursor = 'grab';
            },

            handleWheel(e) {
                e.preventDefault();
                
                // 获取鼠标相对于画布的位置
                const canvasRect = appState.canvas.getBoundingClientRect();
                const mouseX = e.clientX - canvasRect.left;
                const mouseY = e.clientY - canvasRect.top;
                
                // 计算缩放前的鼠标位置对应的世界坐标
                const oldScale = appState.mapScale;
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.5, Math.min(3, oldScale * zoomFactor));
                
                // 计算缩放中心的世界坐标
                const centerX = appState.canvas.width / 2;
                const centerY = appState.canvas.height / 2;
                const scale = 2; // 与worldToScreen中的scale一致
                const offsetX = 400; // 与worldToScreen中的offsetX一致
                const offsetY = -100; // 与worldToScreen中的offsetY一致
                
                // 将鼠标位置转换为世界坐标
                const worldX = (mouseX - centerX - appState.mapOffset.x) / (scale * oldScale) - offsetX;
                const worldY = (mouseY - centerY - appState.mapOffset.y) / (scale * oldScale) - offsetY;
                
                // 更新缩放比例
                appState.mapScale = newScale;
                
                // 计算缩放后的鼠标位置应该对应的屏幕坐标
                const newScreenX = centerX + (worldX + offsetX) * scale * newScale + appState.mapOffset.x;
                const newScreenY = centerY + (worldY + offsetY) * scale * newScale + appState.mapOffset.y;
                
                // 调整地图偏移量，使鼠标位置保持不变
                appState.mapOffset.x += mouseX - newScreenX;
                appState.mapOffset.y += mouseY - newScreenY;
                
                this.render();
            },

            handleTouchStart(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    appState.isDragging = true;
                    appState.lastTouchPos = { 
                        x: e.touches[0].clientX, 
                        y: e.touches[0].clientY 
                    };
                } else if (e.touches.length === 2) {
                    appState.isPinching = true;
                    appState.lastTouchDistance = this.getTouchDistance(e.touches[0], e.touches[1]);
                    // 保存多指落点中心位置
                    appState.lastTouchCenter = this.getTouchCenter(e.touches[0], e.touches[1]);
                }
            },

            handleTouchMove(e) {
                e.preventDefault();
                if (appState.isDragging && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - appState.lastTouchPos.x;
                    const deltaY = e.touches[0].clientY - appState.lastTouchPos.y;
                    
                    // 根据地图缩放比例调整移动速度（使用平方根函数实现更平滑的调整）
                    const speedFactor = Math.sqrt(1 / appState.mapScale);
                    appState.mapOffset.x += deltaX * speedFactor;
                    appState.mapOffset.y += deltaY * speedFactor;
                    
                    appState.lastTouchPos = { 
                        x: e.touches[0].clientX, 
                        y: e.touches[0].clientY 
                    };
                    this.render();
                } else if (appState.isPinching && e.touches.length === 2) {
                    const currentDistance = this.getTouchDistance(e.touches[0], e.touches[1]);
                    const scaleFactor = currentDistance / appState.lastTouchDistance;
                    
                    // 获取当前多指落点中心
                    const currentCenter = this.getTouchCenter(e.touches[0], e.touches[1]);
                    
                    // 保存旧的缩放比例
                    const oldScale = appState.mapScale;
                    
                    // 更新缩放比例
                    appState.mapScale = Math.max(0.5, Math.min(3, appState.mapScale * scaleFactor));
                    appState.lastTouchDistance = currentDistance;
                    
                    // 以多指落点中心为缩放中心，调整地图偏移量
                    this.adjustOffsetForPinchZoom(oldScale, appState.lastTouchCenter, currentCenter);
                    
                    // 更新中心位置
                    appState.lastTouchCenter = currentCenter;
                    
                    this.render();
                }
            },

            handleTouchEnd() {
                appState.isDragging = false;
                appState.isPinching = false;
            },

            getTouchDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            },

            getTouchCenter(touch1, touch2) {
                return {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            },

            adjustOffsetForPinchZoom(oldScale, oldCenter, newCenter) {
                const canvasRect = appState.canvas.getBoundingClientRect();
                
                // 将屏幕坐标转换为相对于画布的坐标
                const oldCenterX = oldCenter.x - canvasRect.left;
                const oldCenterY = oldCenter.y - canvasRect.top;
                const newCenterX = newCenter.x - canvasRect.left;
                const newCenterY = newCenter.y - canvasRect.top;
                
                // 计算缩放前的中心点对应的世界坐标
                const centerX = appState.canvas.width / 2;
                const centerY = appState.canvas.height / 2;
                const scale = 2; // 与worldToScreen中的scale一致
                const offsetX = 400; // 与worldToScreen中的offsetX一致
                const offsetY = -100; // 与worldToScreen中的offsetY一致
                
                // 将旧的中心点位置转换为世界坐标
                const worldX = (oldCenterX - centerX - appState.mapOffset.x) / (scale * oldScale) - offsetX;
                const worldY = (oldCenterY - centerY - appState.mapOffset.y) / (scale * oldScale) - offsetY;
                
                // 计算缩放后的中心点应该对应的屏幕坐标
                const newScreenX = centerX + (worldX + offsetX) * scale * appState.mapScale + appState.mapOffset.x;
                const newScreenY = centerY + (worldY + offsetY) * scale * appState.mapScale + appState.mapOffset.y;
                
                // 调整地图偏移量，使新的中心点位置保持不变
                appState.mapOffset.x += newCenterX - newScreenX;
                appState.mapOffset.y += newCenterY - newScreenY;
            },

            worldToScreen(x, y) {
                const centerX = appState.canvas.width / 2;
                const centerY = appState.canvas.height / 2;
                
                // 根据数据范围优化平面坐标系转换
                // 数据范围：x: -963 到 39.9, y: 18 到 333
                // 使用更合适的缩放因子和偏移量
                const scale = 2; // 优化后的缩放因子
                const offsetX = 400; // x轴偏移，使数据居中显示
                const offsetY = -100; // y轴偏移，使数据居中显示
                
                const screenX = centerX + (x + offsetX) * scale * appState.mapScale + appState.mapOffset.x;
                const screenY = centerY + (y + offsetY) * scale * appState.mapScale + appState.mapOffset.y;
                
                return { x: screenX, y: screenY };
            },

            clearMap() {
                appState.ctx.clearRect(0, 0, appState.canvas.width, appState.canvas.height);
                this.clearStationLabels();
                this.clearLineLabels();
            },

            clearStationLabels() {
                appState.stationLabels.forEach(label => label.remove());
                appState.stationLabels = [];
            },

            clearLineLabels() {
                if (appState.lineLabels) {
                    appState.lineLabels.forEach(label => label.remove());
                    appState.lineLabels = [];
                }
            },

            displayStations(lines) {
                this.clearStationLabels();
                
                lines.forEach(line => {
                    line.stations.forEach(station => {
                        // 跳过节点，不显示节点标记
                        if (station.type === 'node') {
                            return;
                        }
                        
                        const screenPos = this.worldToScreen(station.X, station.Y);
                        
                        // 绘制站点标记 - 通过两个重叠的圆实现黑色描边白色背景
                        
                        // 先绘制大黑圆作为描边
                        appState.ctx.beginPath();
                        const outerRadius = 6 * appState.mapScale;
                        appState.ctx.arc(screenPos.x, screenPos.y, outerRadius, 0, 2 * Math.PI);
                        appState.ctx.fillStyle = '#000000';
                        appState.ctx.fill();
                        
                        // 再绘制内圆作为背景
                        appState.ctx.beginPath();
                        const innerRadius = 5.5 * appState.mapScale;
                        appState.ctx.arc(screenPos.x, screenPos.y, innerRadius, 0, 2 * Math.PI);
                        appState.ctx.fillStyle = '#FFFFFF';
                        appState.ctx.fill();
                        
                        // 添加站名标签
                        this.addStationLabel(station, screenPos.x, screenPos.y);
                    });
                });
            },

            addStationLabel(station, x, y) {
                // 跳过节点，不显示节点标签
                if (station.type === 'node') {
                    return;
                }
                
                const label = document.createElement('div');
                label.className = 'station-label';
                
                // 根据地图缩放比例动态计算字体大小
                const baseFontScale = appState.mapScale;
                const chineseFontSize = Math.max(8, 11 * baseFontScale); // 中文站名基础大小11px
                const englishFontSize = Math.max(6, 9 * baseFontScale);  // 英文站名基础大小9px
                const transferFontSize = Math.max(6, 8 * baseFontScale); // 换乘信息基础大小8px
                const platformFontSize = Math.max(5, 7 * baseFontScale); // 站台信息基础大小7px
                
                // 创建双语显示：中文名称 + 英文名称
                const chineseName = station.name;
                const englishName = station.englishName;
                
                // 创建运营单位信息显示
                let managementInfo = '';
                if (station.management) {
                    managementInfo = `<div class="station-management" style="font-size: ${transferFontSize}px; color: #aaa;">${station.management}</div>`;
                }
                
                // 创建换乘信息显示 - 处理线路数和站台数不等的情况
                let transferInfo = '';
                if (station.transfer && station.transferLines.length > 0) {
                    const transferLines = station.transferLines.join('、');
                    
                    // 只有当有换乘站台信息时才显示站台信息
                    let platformsInfo = '';
                    if (station.transferPlatforms && station.transferPlatforms.length > 0) {
                        const transferPlatforms = station.transferPlatforms.join('、');
                        platformsInfo = `<div class="transfer-platforms" style="font-size: ${platformFontSize}px;">换乘站台：${transferPlatforms}</div>`;
                    }
                    
                    transferInfo = `
                        <div class="station-transfer-info" style="font-size: ${transferFontSize}px;">
                            <div class="transfer-lines">换乘线路：${transferLines}</div>
                            ${platformsInfo}
                        </div>
                    `;
                }
                
                label.innerHTML = `
                    <div class="station-name-chinese" style="font-size: ${chineseFontSize}px;">${chineseName}</div>
                    <div class="station-name-english" style="font-size: ${englishFontSize}px;">${englishName}</div>
                    ${managementInfo}
                    ${transferInfo}
                `;
                
                // 站名标签固定在站点上方
                const labelOffset = 20 * baseFontScale;
                let left = x;
                let top = y - labelOffset; // 固定在站点上方
                
                // 使用CSS transform实现精确居中
                // CSS中已有 transform: translate(-50%, -100%); 实现水平居中和垂直对齐
                
                label.style.left = left + 'px';
                label.style.top = top + 'px';
                
                document.querySelector('.map-container').appendChild(label);
                appState.stationLabels.push(label);
            },
            
            // 添加线路ID标签（带线路颜色背景）
            addLineLabel(line, x, y) {
                const label = document.createElement('div');
                label.className = 'line-label';
                
                // 根据地图缩放比例动态计算字体大小
                const baseFontScale = appState.mapScale;
                const fontSize = Math.max(10, 14 * baseFontScale);
                
                // 设置标签样式
                label.style.fontSize = fontSize + 'px';
                label.style.fontWeight = 'bold';
                label.style.color = '#FFFFFF'; // 白色文字
                label.style.backgroundColor = line.color; // 线路颜色背景
                label.style.padding = '2px 6px';
                label.style.borderRadius = '4px';
                label.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.3)';
                label.style.whiteSpace = 'nowrap';
                label.style.zIndex = '90'; // 低于站点标签但高于线路
                label.style.pointerEvents = 'none';
                label.style.position = 'absolute';
                label.style.textAlign = 'center';
                
                // 设置标签内容（步行路线路只显示名称，不显示ID）
                label.textContent = line.name;
                
                // 设置标签位置：更靠近线路中心，确保用户能看到
                // 使用更小的偏移量，让标签更贴近线路
                const offset = 6 * baseFontScale; // 使用较小的偏移量
                
                // 计算标签的边界位置
                let finalX = x + offset;
                let finalY = y - offset;
                
                // 简单的边界检查，确保标签在可视区域内
                const mapContainer = document.querySelector('.map-container');
                const containerRect = mapContainer.getBoundingClientRect();
                const containerWidth = containerRect.width;
                const containerHeight = containerRect.height;
                
                // 计算标签的预估尺寸
                const labelWidth = label.textContent.length * fontSize * 0.6 + 12;
                const labelHeight = fontSize + 4;
                
                // 确保标签不超出边界
                if (finalX - labelWidth/2 < 0) {
                    finalX = labelWidth/2 + 10;
                }
                if (finalX + labelWidth/2 > containerWidth) {
                    finalX = containerWidth - labelWidth/2 - 10;
                }
                if (finalY - labelHeight/2 < 0) {
                    finalY = labelHeight/2 + 10;
                }
                if (finalY + labelHeight/2 > containerHeight) {
                    finalY = containerHeight - labelHeight/2 - 10;
                }
                
                label.style.left = finalX + 'px';
                label.style.top = finalY + 'px';
                
                // 使用CSS transform实现精确居中
                label.style.transform = 'translate(-50%, -50%)';
                
                // 增强阴影效果，提高可读性
                label.style.textShadow = '0 2px 4px rgba(0, 0, 0, 0.7)';
                
                // 添加边框增强对比度
                label.style.border = '1px solid rgba(255, 255, 255, 0.3)';
                
                document.querySelector('.map-container').appendChild(label);
                appState.lineLabels = appState.lineLabels || [];
                appState.lineLabels.push(label);
            },
            
            // 获取站点的英文名称
            getEnglishName(chineseName) {
                // 从解析的数据中查找对应的英文名称
                const station = appState.stations.find(s => s.name === chineseName);
                return station ? station.englishName : chineseName;
            },

            // 检测线路上的转折点
            findTurnPoints(line) {
                const turnPoints = [];
                
                if (line.stations.length < 3) {
                    return turnPoints; // 少于3个站点无法形成转折
                }
                
                // 检查每个中间站点是否为转折点
                for (let i = 1; i < line.stations.length - 1; i++) {
                    const prevStation = line.stations[i - 1];
                    const currentStation = line.stations[i];
                    const nextStation = line.stations[i + 1];
                    
                    // 计算向量
                    const vec1 = {
                        x: currentStation.X - prevStation.X,
                        y: currentStation.Y - prevStation.Y
                    };
                    const vec2 = {
                        x: nextStation.X - currentStation.X,
                        y: nextStation.Y - currentStation.Y
                    };
                    
                    // 计算向量夹角（使用点积公式）
                    const dotProduct = vec1.x * vec2.x + vec1.y * vec2.y;
                    const magnitude1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
                    const magnitude2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
                    
                    if (magnitude1 > 0 && magnitude2 > 0) {
                        const cosAngle = dotProduct / (magnitude1 * magnitude2);
                        const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);
                        
                        // 如果夹角小于150度，认为是转折点
                        if (angle < 150) {
                            turnPoints.push({
                                station: currentStation,
                                angle: angle,
                                index: i
                            });
                        }
                    }
                }
                
                return turnPoints;
            },

            // 绘制带转折点的线路（支持支线）
            displayLinesWithTurns(lines) {
                lines.forEach(line => {
                    // 检查是否是支线
                    const isBranchLine = line.branchOf && line.branchName;
                    
                    if (line.stations.length > 1) {
                        // 查找转折点
                        const turnPoints = this.findTurnPoints(line);
                        
                        // 如果没有转折点，直接绘制直线
                        if (turnPoints.length === 0) {
                            this.drawStraightLine(line, isBranchLine);
                        } else {
                            // 分段绘制线路，在转折点处断开
                            this.drawSegmentedLine(line, turnPoints, isBranchLine);
                        }
                    }
                    
                    // 如果这条线路有支线，也绘制支线
                    if (line.branches && Object.keys(line.branches).length > 0) {
                        Object.values(line.branches).forEach(branchLine => {
                            if (branchLine.stations.length > 1) {
                                const branchTurnPoints = this.findTurnPoints(branchLine);
                                
                                if (branchTurnPoints.length === 0) {
                                    this.drawStraightLine(branchLine, true);
                                } else {
                                    this.drawSegmentedLine(branchLine, branchTurnPoints, true);
                                }
                            }
                        });
                    }
                });
            },

            // 绘制直线线路（无转折点）
            drawStraightLine(line, isBranchLine = false) {
                appState.ctx.beginPath();
                
                line.stations.forEach((station, index) => {
                    const screenPos = this.worldToScreen(station.X, station.Y);
                    
                    if (index === 0) {
                        appState.ctx.moveTo(screenPos.x, screenPos.y);
                    } else {
                        appState.ctx.lineTo(screenPos.x, screenPos.y);
                    }
                });
                
                this.applyLineStyle(line, isBranchLine);
            },

            // 绘制分段线路（有转折点）
            drawSegmentedLine(line, turnPoints, isBranchLine = false) {
                const segments = [];
                let startIndex = 0;
                
                // 根据转折点分割线路
                turnPoints.forEach(turnPoint => {
                    segments.push({
                        start: startIndex,
                        end: turnPoint.index,
                        stations: line.stations.slice(startIndex, turnPoint.index + 1)
                    });
                    startIndex = turnPoint.index;
                });
                
                // 添加最后一段
                segments.push({
                    start: startIndex,
                    end: line.stations.length - 1,
                    stations: line.stations.slice(startIndex)
                });
                
                // 绘制每段线路
                segments.forEach(segment => {
                    if (segment.stations.length > 1) {
                        appState.ctx.beginPath();
                        
                        segment.stations.forEach((station, index) => {
                            const screenPos = this.worldToScreen(station.X, station.Y);
                            
                            if (index === 0) {
                                appState.ctx.moveTo(screenPos.x, screenPos.y);
                            } else {
                                appState.ctx.lineTo(screenPos.x, screenPos.y);
                            }
                        });
                        
                        this.applyLineStyle(line, isBranchLine);
                    }
                });
            },

            // 应用线路样式（支持支线）
            applyLineStyle(line, isBranchLine = false) {
                appState.ctx.strokeStyle = line.color;
                
                // 中国铁路特快线样式：更粗的线条和虚线样式
                console.log(`渲染线路 ${line.name} - isExpress: ${line.isExpress}, lineType: ${line.lineType}, isBranchLine: ${isBranchLine}`);
                
                if (line.lineType === 'walking') {
                    // 步行路样式：特快线样式改灰，去除描边，增加线段距离，添加圆角
                    console.log(`应用步行路样式到线路 ${line.name}`);
                    
                    appState.ctx.lineCap = 'round'; // 添加圆角效果
                    
                    // 根据地图缩放比例动态调整虚线样式，增加线段距离
                    const dashLength = 12 * appState.mapScale;
                    const gapLength = 12 * appState.mapScale; // 增加间隙距离
                    
                    // 直接绘制灰色虚线，去除描边
                    appState.ctx.setLineDash([dashLength, gapLength]); // 虚线样式
                    appState.ctx.strokeStyle = '#808080'; // 灰色
                    appState.ctx.lineWidth = 6 * appState.mapScale; // 与特快线彩色线条宽度一致
                    appState.ctx.stroke();
                    
                } else if (isBranchLine) {
                    // 支线样式：更细的虚线，与主线路区分
                    console.log(`应用支线样式到线路 ${line.name}`);
                    
                    appState.ctx.lineCap = 'round'; // 圆角效果
                    
                    // 根据地图缩放比例动态调整虚线样式
                    const dashLength = 8 * appState.mapScale;
                    const gapLength = 6 * appState.mapScale;
                    
                    // 支线使用更细的虚线，无描边
                    appState.ctx.setLineDash([dashLength, gapLength]); // 虚线样式
                    appState.ctx.strokeStyle = line.color;
                    appState.ctx.lineWidth = 4 * appState.mapScale; // 比主线路细
                    appState.ctx.stroke();
                    
                } else if (line.isExpress) {
                    console.log(`应用特快线样式到线路 ${line.name}`);
                    
                    // 中国铁路特快线样式：无圆角，黑色描边
                    appState.ctx.lineCap = 'butt'; // 无圆角
                    
                    // 根据地图缩放比例动态调整虚线样式
                    const dashLength = 12 * appState.mapScale;
                    const gapLength = 8 * appState.mapScale;
                    
                    // 第一步：绘制完整的黑色背景描边（包括线段和间隙）
                    appState.ctx.setLineDash([]); // 实线用于背景描边
                    appState.ctx.strokeStyle = '#000000';
                    appState.ctx.lineWidth = 8 * appState.mapScale; // 黑色描边宽度
                    appState.ctx.stroke();
                    
                    // 第二步：绘制白色背景（包括线段和间隙）
                    appState.ctx.setLineDash([]); // 实线用于白色背景
                    appState.ctx.strokeStyle = '#FFFFFF';
                    appState.ctx.lineWidth = 6 * appState.mapScale; // 白色背景宽度
                    appState.ctx.stroke();
                    
                    // 第三步：绘制彩色虚线线段
                    appState.ctx.setLineDash([dashLength, gapLength]); // 虚线样式
                    appState.ctx.strokeStyle = line.color;
                    appState.ctx.lineWidth = 6 * appState.mapScale; // 彩色线条宽度
                    appState.ctx.stroke();
                    
                } else {
                    appState.ctx.lineCap = 'round';
                    appState.ctx.lineWidth = 4 * appState.mapScale;
                    appState.ctx.setLineDash([]); // 实线样式
                    appState.ctx.stroke();
                }
            },

            // 显示线路编号标签
            displayLineLabels(lines) {
                lines.forEach(line => {
                    if (line.stations.length > 1 && line.lineType !== 'walking') {
                        // 计算线路的几何中点，而不是站点位置
                        const startStation = line.stations[0];
                        const endStation = line.stations[line.stations.length - 1];
                        
                        // 计算线路的几何中心点
                        const centerX = (startStation.X + endStation.X) / 2;
                        const centerY = (startStation.Y + endStation.Y) / 2;
                        
                        // 将世界坐标转换为屏幕坐标
                        const centerScreenPos = this.worldToScreen(centerX, centerY);
                        
                        // 设置文字样式
                        appState.ctx.font = `${12 * appState.mapScale}px Arial`;
                        appState.ctx.textAlign = 'center';
                        appState.ctx.textBaseline = 'middle';
                        
                        // 添加白色描边背景，提高可读性
                        appState.ctx.strokeStyle = '#FFFFFF';
                        appState.ctx.lineWidth = 3 * appState.mapScale;
                        appState.ctx.strokeText(line.id, centerScreenPos.x, centerScreenPos.y);
                        
                        // 绘制与线路颜色一致的编号文字
                        appState.ctx.fillStyle = line.color;
                        appState.ctx.fillText(line.id, centerScreenPos.x, centerScreenPos.y);
                    }
                });
            },

            displayRoute(route, transfers) {
                transfers.forEach(transfer => {
                    const stations = transfer.stations.map(stationName => 
                        appState.stations.find(s => s.name === stationName)
                    ).filter(Boolean);
                    
                    if (stations.length > 1) {
                        appState.ctx.beginPath();
                        
                        stations.forEach((station, index) => {
                            const screenPos = this.worldToScreen(station.X, station.Y);
                            if (index === 0) {
                                appState.ctx.moveTo(screenPos.x, screenPos.y);
                            } else {
                                appState.ctx.lineTo(screenPos.x, screenPos.y);
                            }
                        });
                        
                        appState.ctx.strokeStyle = dataProcessor.getLineColor(transfer.line);
                        appState.ctx.lineWidth = 6 * appState.mapScale;
                        appState.ctx.setLineDash([5, 5]);
                        appState.ctx.stroke();
                        appState.ctx.setLineDash([]);
                    }
                });
            },

            render() {
                this.clearMap();
                
                // 设置白色背景
                appState.ctx.fillStyle = '#ffffff';
                appState.ctx.fillRect(0, 0, appState.canvas.width, appState.canvas.height);
                
                if (appState.lines.length > 0) {
                    // 使用新的带转折点的线路绘制方法
                    this.displayLinesWithTurns(appState.lines);
                    this.displayLineLabels(appState.lines);
                    this.displayStations(appState.lines);
                }
            },

            // 显示节点转折点
            displayNodes() {
                if (appState.nodes && appState.nodes.length > 0) {
                    appState.nodes.forEach(node => {
                        const screenPos = this.worldToScreen(node.X, node.Y);
                        
                        // 绘制节点标记
                        appState.ctx.beginPath();
                        appState.ctx.arc(screenPos.x, screenPos.y, 6 * appState.mapScale, 0, 2 * Math.PI);
                        appState.ctx.fillStyle = node.type === 'turn' ? '#FF6B6B' : '#4ECDC4';
                        appState.ctx.fill();
                        
                        // 添加白色边框
                        appState.ctx.strokeStyle = '#FFFFFF';
                        appState.ctx.lineWidth = 2 * appState.mapScale;
                        appState.ctx.stroke();
                        
                        // 显示节点名称（可选）
                        if (appState.mapScale > 0.5) {
                            appState.ctx.font = `${10 * appState.mapScale}px Arial`;
                            appState.ctx.fillStyle = '#333333';
                            appState.ctx.textAlign = 'center';
                            appState.ctx.textBaseline = 'top';
                            appState.ctx.fillText(node.name, screenPos.x, screenPos.y + 10 * appState.mapScale);
                        }
                    });
                }
            },

            // 自动检测并创建节点转折点（作为特殊站点处理）
            detectAndCreateNodes(lines) {
                const nodes = [];
                const nodeMap = new Map(); // 用于去重
                
                lines.forEach(line => {
                    if (line.stations.length < 3) return; // 少于3个站点无法形成转折
                    
                    // 检测线路上的转折点
                    const turnPoints = this.findTurnPoints(line);
                    
                    turnPoints.forEach(turnPoint => {
                        const station = turnPoint.station;
                        const nodeKey = `${station.X}_${station.Y}`;
                        
                        // 避免重复节点
                        if (!nodeMap.has(nodeKey)) {
                            // 将节点作为特殊站点处理
                            const node = {
                                id: `node_${nodes.length + 1}`,
                                name: `${station.name}_转折点`,
                                X: station.X,
                                Y: station.Y,
                                type: 'node', // 特殊类型：节点
                                originalStation: station.name,
                                line: line.name,
                                englishName: `${station.englishName || station.name}_TurnPoint`,
                                lineName: line.name
                            };
                            
                            nodes.push(node);
                            nodeMap.set(nodeKey, node);
                        }
                    });
                });
                
                return nodes;
            },

            // 图例相关功能
            initLegend() {
                this.isLegendExpanded = true;
                this.updateLegend();
            },

            toggleLegend() {
                const legendContainer = document.getElementById('legendContainer');
                const toggleButton = legendContainer.querySelector('.legend-toggle');
                
                this.isLegendExpanded = !this.isLegendExpanded;
                
                if (this.isLegendExpanded) {
                    legendContainer.classList.remove('collapsed');
                    toggleButton.textContent = '▼';
                    this.updateLegend();
                } else {
                    legendContainer.classList.add('collapsed');
                    toggleButton.textContent = '▶';
                }
            },

            updateLegend() {
                if (!this.isLegendExpanded || !appState.lines || appState.lines.length === 0) return;
                
                const legendContent = document.getElementById('legendContent');
                legendContent.innerHTML = '';
                
                // 按线路类型分组，过滤掉步行路
                const linesByType = {};
                appState.lines.forEach(line => {
                    if (line.lineType === 'walking') return; // 跳过步行路
                    if (!linesByType[line.lineType]) {
                        linesByType[line.lineType] = [];
                    }
                    linesByType[line.lineType].push(line);
                });
                
                // 按特定顺序显示线路类型，排除步行路
                const typeOrder = ['subway', 'railway', 'bus'];
                
                typeOrder.forEach(type => {
                    if (linesByType[type]) {
                        linesByType[type].forEach(line => {
                            this.addLegendItem(line, legendContent);
                        });
                    }
                });
            },

            addLegendItem(line, container) {
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                
                // 根据是否为特快线路确定线路类型
                const typeName = line.isExpress ? '快船' : '铁路';
                
                // 获取起点站和终点站
                const startStation = line.stations[0]?.name || '未知';
                const endStation = line.stations[line.stations.length - 1]?.name || '未知';
                
                // 获取线路特征描述
                let features = '';
                if (line.branchOf) {
                    features += '支线';
                }
                
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${line.color}"></div>
                    <div class="legend-info">
                        <div class="legend-line-name">${line.name}</div>
                        <div class="legend-line-details">
                            <span class="legend-line-type">${typeName}</span>
                            ${features ? `<span>${features}</span>` : ''}
                        </div>
                        <div class="legend-stations">${startStation} ↔ ${endStation}</div>
                    </div>
                `;
                
                container.appendChild(legendItem);
            },

            // 在Canvas上绘制图例（用于图片保存）
            drawLegendOnCanvas(ctx, scale) {
                if (!appState.lines || appState.lines.length === 0) return;
                
                // 过滤掉步行路线路
                const filteredLines = appState.lines.filter(line => line.lineType !== 'walking');
                if (filteredLines.length === 0) return;
                
                // 图例项参数
                const itemWidth = 250 * scale;
                const itemHeight = 80 * scale;
                const padding = 20 * scale;
                const spacing = 15 * scale;
                
                // 计算每行最多能容纳的图例项数量
                const maxItemsPerRow = Math.floor((ctx.canvas.width - padding * 2) / (itemWidth + spacing));
                const rows = Math.ceil(filteredLines.length / maxItemsPerRow);
                
                // 计算图例总高度和位置
                const totalHeight = rows * itemHeight + (rows - 1) * spacing;
                const legendY = ctx.canvas.height - (totalHeight + 50 * scale); // 底部留出50像素间距
                
                // 绘制图例背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1 * scale;
                ctx.fillRect(padding, legendY - padding, 
                           ctx.canvas.width - padding * 2, totalHeight + padding * 2);
                ctx.strokeRect(padding, legendY - padding, 
                             ctx.canvas.width - padding * 2, totalHeight + padding * 2);
                
                // 绘制图例标题
                ctx.font = `${16 * scale}px Arial`;
                ctx.fillStyle = '#2c3e50';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText('线路图例', ctx.canvas.width / 2, legendY - padding - 25 * scale);
                
                // 绘制每条线路的图例项（自动换行，左对齐）
                filteredLines.forEach((line, index) => {
                    const row = Math.floor(index / maxItemsPerRow);
                    const col = index % maxItemsPerRow;
                    
                    // 计算每行的起始位置（左对齐）
                    const rowStartX = padding;
                    
                    const itemX = rowStartX + col * (itemWidth + spacing);
                    const itemY = legendY + row * (itemHeight + spacing);
                    
                    // 绘制颜色块
                    ctx.fillStyle = line.color;
                    ctx.fillRect(itemX, itemY, 20 * scale, 20 * scale);
                    
                    // 绘制线路名称
                    ctx.font = `${14 * scale}px Arial`;
                    ctx.fillStyle = '#2c3e50';
                    ctx.textAlign = 'left';
                    ctx.fillText(line.name, itemX + 25 * scale, itemY);
                    
                    // 绘制线路类型和特征
                    ctx.font = `${12 * scale}px Arial`;
                    ctx.fillStyle = '#666';
                    
                    // 根据是否为特快线路确定线路类型
                    const typeName = line.isExpress ? '快船' : '铁路';
                    let features = '';
                    if (line.branchOf) features += '支线';
                    
                    ctx.fillText(`${typeName}${features ? ` - ${features}` : ''}`, 
                               itemX + 25 * scale, itemY + 20 * scale);
                    
                    // 绘制起点终点
                    const startStation = line.stations[0]?.name || '未知';
                    const endStation = line.stations[line.stations.length - 1]?.name || '未知';
                    ctx.fillText(`${startStation} ↔ ${endStation}`, 
                               itemX + 25 * scale, itemY + 40 * scale);
                });
            }

        };

        // 事件处理函数
        window.eventHandlers = {
            init() {
                // 初始化地图
                mapRenderer.init();
                
                // 初始化图例
                mapRenderer.initLegend();
                
                // 检测是否为移动端设备，如果是则隐藏保存按钮
                this.detectMobileAndHideSaveButton();
                
                // 绑定事件（使用箭头函数保持正确的this上下文）
                document.getElementById('calculateRoute').addEventListener('click', () => this.handleRouteCalculation());
                document.getElementById('zoomIn').addEventListener('click', () => this.handleZoomIn());
                document.getElementById('zoomOut').addEventListener('click', () => this.handleZoomOut());
                document.getElementById('resetView').addEventListener('click', () => this.handleResetView());
                document.getElementById('saveImage').addEventListener('click', () => this.handleSaveImage());
                
                // 绑定搜索功能事件
                this.initSearchFunctionality();
                
                // 启动时静默加载示例数据
                setTimeout(() => {
                    this.handleLoadSampleSilent();
                }, 100);
            },

            // 检测移动端设备并隐藏保存按钮
            detectMobileAndHideSaveButton() {
                // 检测是否为移动端设备
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                               (window.innerWidth <= 768 && window.innerHeight <= 1024);
                
                if (isMobile) {
                    const saveButton = document.getElementById('saveImage');
                    if (saveButton) {
                        saveButton.style.display = 'none';
                        console.log('移动端访问，已隐藏保存按钮');
                    }
                }
            },

            initSearchFunctionality() {
                // 搜索框已被删除，此函数现在只保留空实现
                // 可搜索下拉框的初始化在数据加载完成后调用
            },
            
            initSearchableSelects() {
                // 为起点站和终点站初始化可搜索下拉框
                this.initSearchableSelect('startStation');
                this.initSearchableSelect('endStation');
            },
            
            initSearchableSelect(selectId) {
                const originalSelect = document.getElementById(selectId);
                const searchableSelect = document.querySelector(`.searchable-select[data-for="${selectId}"]`);
                const searchInput = searchableSelect.querySelector('.searchable-select-input');
                const optionsContainer = searchableSelect.querySelector('.searchable-select-options');
                
                // 初始化选项
                this.populateSearchableOptions(selectId);
                
                // 搜索输入事件
                searchInput.addEventListener('input', (e) => {
                    const query = e.target.value.trim().toLowerCase();
                    const options = optionsContainer.querySelectorAll('.searchable-select-option');
                    
                    options.forEach(option => {
                        const text = option.textContent.toLowerCase();
                        if (text.includes(query)) {
                            option.style.display = 'block';
                        } else {
                            option.style.display = 'none';
                        }
                    });
                    
                    // 显示选项容器
                    optionsContainer.style.display = 'block';
                });
                
                // 点击选项事件
                optionsContainer.addEventListener('click', (e) => {
                    const option = e.target.closest('.searchable-select-option');
                    if (option) {
                        const value = option.dataset.value;
                        // 从选项的HTML内容中提取站点名称（第一个div的内容）
                        const stationName = option.querySelector('.search-result-name')?.textContent || option.textContent;
                        
                        // 更新搜索输入框显示（只显示站点名称）
                        searchInput.value = stationName;
                        
                        // 更新原始select元素
                        originalSelect.value = value;
                        
                        // 隐藏选项容器
                        optionsContainer.style.display = 'none';
                        
                        // 显示成功消息
                        utils.showNotification(`已选择站点：${stationName}`);
                    }
                });
                
                // 点击外部关闭选项容器
                document.addEventListener('click', (e) => {
                    if (!searchableSelect.contains(e.target)) {
                        optionsContainer.style.display = 'none';
                    }
                });
                
                // 搜索框聚焦时显示所有选项
                searchInput.addEventListener('focus', () => {
                    const options = optionsContainer.querySelectorAll('.searchable-select-option');
                    options.forEach(option => option.style.display = 'block');
                    optionsContainer.style.display = 'block';
                });
                
                // 监听原始select变化，同步到搜索输入框
                originalSelect.addEventListener('change', () => {
                    const selectedOption = originalSelect.options[originalSelect.selectedIndex];
                    if (selectedOption) {
                        searchInput.value = selectedOption.text;
                    }
                    
                    // 检查是否起点和终点都已选择，如果是则自动计算路径
                    eventHandlers.autoCalculateRoute();
                });
            },
            
            populateSearchableOptions(selectId) {
                const originalSelect = document.getElementById(selectId);
                const searchableSelect = document.querySelector(`.searchable-select[data-for="${selectId}"]`);
                const optionsContainer = searchableSelect.querySelector('.searchable-select-options');
                
                // 清空现有选项
                optionsContainer.innerHTML = '';
                
                // 添加所有选项，显示双语和线路信息
                for (let i = 0; i < originalSelect.options.length; i++) {
                    const option = originalSelect.options[i];
                    if (option.value) {
                        // 解析站点名称和线路信息
                        const stationName = option.text;
                        const valueParts = option.value.split('_');
                        const lineId = valueParts.length > 1 ? valueParts[1] : '';
                        
                        // 查找站点详细信息
                        const station = appState.stations.find(s => s.name === stationName && s.line === lineId);
                        
                        const optionElement = document.createElement('div');
                        optionElement.className = 'searchable-select-option';
                        optionElement.dataset.value = option.value;
                        
                        if (station && station.englishName) {
                            // 显示双语和线路信息
                            optionElement.innerHTML = `
                                <div class="search-result-name">${stationName}</div>
                                <div class="search-result-line">${station.englishName} - ${station.lineName || station.line}</div>
                            `;
                        } else {
                            // 如果没有英文名，只显示站点名称和线路
                            optionElement.innerHTML = `
                                <div class="search-result-name">${stationName}</div>
                                <div class="search-result-line">${stationName} - ${lineId}</div>
                            `;
                        }
                        
                        optionsContainer.appendChild(optionElement);
                    }
                }
            },

            handleFileImport(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                const self = this; // 保存正确的this引用
                reader.onload = function(e) {
                    try {
                        const fileContent = e.target.result;
                        let data = {};
                        
                        if (file.name.endsWith('.csv')) {
                            data = dataProcessor.parseCSVData(fileContent);
                        } else if (file.name.endsWith('.json')) {
                            // JSON格式可能返回数组，需要转换为新的数据结构
                            const stations = dataProcessor.parseJSONData(fileContent);
                            data = {
                                lines: dataProcessor.groupStationsByLine(stations),
                                stations: stations
                            };
                        } else {
                            throw new Error('不支持的文件格式');
                        }
                        
                        if (data.stations.length === 0) {
                            throw new Error('未找到有效的站点数据');
                        }
                        
                        // 处理数据
                        appState.stations = data.stations;
                        appState.lines = data.lines;
                        
                        // 自动检测并添加节点转折点（作为特殊站点处理）
                        const detectedNodes = this.detectAndCreateNodes(data.lines);
                        
                        // 将节点合并到站点数组中
                        appState.stations = [...data.stations, ...detectedNodes];
                        
                        // 重新构建图（包含节点）
                        appState.graph = routePlanner.buildGraph(data.lines);
                        
                        // 更新UI
                        mapRenderer.clearMap();
                        mapRenderer.render();
                        
                        // 更新站点选择下拉菜单
                        self.updateStationSelects();
                        
                        utils.showNotification(`成功导入 ${data.stations.length} 个站点数据，检测到 ${detectedNodes.length} 个转折点`);
                        
                    } catch (error) {
                        utils.showNotification(error.message, 'error');
                        console.error('文件导入错误:', error);
                    }
                };
                
                reader.readAsText(file);
            },

            updateStationSelects() {
                const startSelect = document.getElementById('startStation');
                const endSelect = document.getElementById('endStation');
                
                // 清空现有选项（保留第一个选项）
                while (startSelect.options.length > 1) startSelect.remove(1);
                while (endSelect.options.length > 1) endSelect.remove(1);
                
                // 使用Set来去重，只显示唯一的站点名称
                const uniqueStationNames = [...new Set(appState.stations.map(station => station.name))];
                
                // 添加去重后的站点选项
                uniqueStationNames.forEach(stationName => {
                    // 查找该站点的第一个线路作为默认值
                    const firstStation = appState.stations.find(station => station.name === stationName);
                    const value = `${stationName}_${firstStation.line}`;
                    const option1 = new Option(stationName, value);
                    const option2 = new Option(stationName, value);
                    startSelect.add(option1);
                    endSelect.add(option2);
                });
                
                // 更新可搜索下拉框的选项
                if (typeof this.populateSearchableOptions === 'function') {
                    this.populateSearchableOptions('startStation');
                    this.populateSearchableOptions('endStation');
                }
            },

            handleClearMap() {
                appState.stations = [];
                appState.lines = [];
                appState.graph = null;
                mapRenderer.clearMap();
                

                
                const routeInfo = document.getElementById('routeInfo');
                routeInfo.innerHTML = '<p>请选择起点和终点站进行路径规划</p>';
                
                const transferInfo = document.getElementById('transferInfo');
                transferInfo.innerHTML = '<p>路径规划完成后显示换乘信息</p>';
                
                this.updateStationSelects();
                utils.showNotification('地图已清除');
            },

            handleLoadSample() {
                try {
                    console.log('开始加载地铁数据...');
                    
                    // 使用全局变量subwayData和stationCoordinates，该变量在subway-data.js文件中定义
                    if (typeof subwayData === 'undefined' || typeof stationCoordinates === 'undefined') {
                        throw new Error('地铁数据未加载，请确保subway-data.js文件已正确引入');
                    }
                    
                    // 解析地铁线路数据
                    const subwayLinesData = dataProcessor.parseLineData(subwayData);
                    console.log('解析后的地铁线路数据:', subwayLinesData);
                    
                    // 检查特快线字段
                    subwayLinesData.forEach(line => {
                        console.log(`地铁线路 ${line.lineName} - isExpress: ${line.isExpress}, 类型: ${typeof line.isExpress}`);
                    });
                    
                    // 解析地铁站点坐标数据
                    const subwayStationsData = dataProcessor.parseStationData(stationCoordinates);
                    console.log('解析后的地铁站点数据:', subwayStationsData);
                    
                    // 合并地铁数据
                    const subwayCombinedData = dataProcessor.combineLineAndStationData(subwayLinesData, subwayStationsData);
                    console.log('合并后的地铁数据:', subwayCombinedData);
                    
                    // 检查合并后的特快线信息
                    subwayCombinedData.lines.forEach(line => {
                        console.log(`合并后地铁线路 ${line.name} - isExpress: ${line.isExpress}, 类型: ${typeof line.isExpress}`);
                    });
                    
                    // 初始化应用状态
                    appState.stations = [...subwayCombinedData.stations];
                    appState.lines = [...subwayCombinedData.lines];
                    
                    // 如果存在步行路数据，加载并合并
                    if (typeof walkingData !== 'undefined') {
                        console.log('开始加载步行路数据...');
                        
                        // 解析步行路线路数据
                        const walkingLinesData = dataProcessor.parseLineData(walkingData);
                        console.log('解析后的步行路线路数据:', walkingLinesData);
                        
                        // 步行路站点直接调用subway-data.js中的站点数据
                        // 使用地铁站点数据作为步行路站点的坐标来源
                        const walkingCombinedData = dataProcessor.combineLineAndStationData(walkingLinesData, subwayStationsData);
                        console.log('合并后的步行路数据:', walkingCombinedData);
                        
                        // 合并到应用状态
                        appState.stations = [...appState.stations, ...walkingCombinedData.stations];
                        appState.lines = [...appState.lines, ...walkingCombinedData.lines];
                        
                        console.log(`成功加载 ${walkingCombinedData.lines.length} 条步行路线路`);
                    }
                    
                    // 解析并添加节点数据（作为特殊站点处理）
                    if (typeof nodeData !== 'undefined') {
                        console.log('开始解析节点数据...');
                        const parsedNodes = dataProcessor.parseNodeData(nodeData);
                        console.log('解析后的节点数据:', parsedNodes);
                        
                        // 将节点插入到线路站点序列中
                        dataProcessor.insertNodesIntoLineSequences(appState.lines, parsedNodes);
                        
                        // 将节点合并到站点数组中
                        appState.stations = [...appState.stations, ...parsedNodes];
                        console.log(`成功加载 ${parsedNodes.length} 个节点数据`);
                    }
                    
                    appState.graph = routePlanner.buildGraph(appState.lines);
                    
                    console.log('应用状态更新完成:', {
                        stations: appState.stations.length,
                        lines: appState.lines.length,
                        graph: appState.graph ? '已构建' : '未构建'
                    });
                    
                    // 更新UI
                    mapRenderer.clearMap();
                    mapRenderer.render();
                    
                    // 设置地图中心为旧园站
                    const jiuyuanStation = appState.stations.find(station => station.name === '旧园');
                    if (jiuyuanStation) {
                        // 计算旧园站的屏幕坐标
                        const screenPos = mapRenderer.worldToScreen(jiuyuanStation.X, jiuyuanStation.Y);
                        const canvasCenterX = appState.canvas.width / 2;
                        const canvasCenterY = appState.canvas.height / 2;
                        
                        // 设置地图偏移量，使旧园站位于屏幕中心
                        appState.mapOffset.x = canvasCenterX - screenPos.x;
                        appState.mapOffset.y = canvasCenterY - screenPos.y;
                        
                        // 重新渲染地图
                        mapRenderer.render();
                    }
                    
                    // 更新站点选择下拉菜单
                    this.updateStationSelects();
                    
                    // 初始化可搜索下拉框
                    if (typeof this.initSearchableSelects === 'function') {
                        this.initSearchableSelects();
                    }
                    
                    // 更新图例
                    if (typeof mapRenderer.updateLegend === 'function') {
                        mapRenderer.updateLegend();
                    }
                    
                    console.log('subway-data.js数据加载完成');
                    utils.showNotification(`成功加载 ${appState.stations.length} 个站点数据`);
                    
                } catch (error) {
                    console.error('数据加载错误:', error);
                    utils.showNotification('数据加载失败: ' + error.message, 'error');
                }
            },

            handleLoadSampleSilent() {
                try {
                    console.log('开始静默加载地铁数据...');
                    
                    // 使用全局变量subwayData和stationCoordinates，该变量在subway-data.js文件中定义
                    if (typeof subwayData === 'undefined' || typeof stationCoordinates === 'undefined') {
                        console.error('地铁数据未加载，请确保subway-data.js文件已正确引入');
                        return;
                    }
                    
                    // 解析地铁线路数据
                    const subwayLinesData = dataProcessor.parseLineData(subwayData);
                    
                    // 解析地铁站点坐标数据
                    const subwayStationsData = dataProcessor.parseStationData(stationCoordinates);
                    
                    // 合并地铁数据
                    const subwayCombinedData = dataProcessor.combineLineAndStationData(subwayLinesData, subwayStationsData);
                    
                    // 初始化应用状态
                    appState.stations = [...subwayCombinedData.stations];
                    appState.lines = [...subwayCombinedData.lines];
                    
                    // 如果存在步行路数据，加载并合并
                    if (typeof walkingData !== 'undefined') {
                        // 解析步行路线路数据
                        const walkingLinesData = dataProcessor.parseLineData(walkingData);
                        
                        // 步行路站点直接调用subway-data.js中的站点数据
                        const walkingCombinedData = dataProcessor.combineLineAndStationData(walkingLinesData, subwayStationsData);
                        
                        // 合并到应用状态
                        appState.stations = [...appState.stations, ...walkingCombinedData.stations];
                        appState.lines = [...appState.lines, ...walkingCombinedData.lines];
                    }
                    
                    // 解析并添加节点数据（作为特殊站点处理）
                    if (typeof nodeData !== 'undefined') {
                        console.log('开始静默解析节点数据...');
                        const parsedNodes = dataProcessor.parseNodeData(nodeData);
                        
                        // 将节点插入到线路站点序列中
                        dataProcessor.insertNodesIntoLineSequences(appState.lines, parsedNodes);
                        
                        // 将节点合并到站点数组中
                        appState.stations = [...appState.stations, ...parsedNodes];
                        console.log(`静默加载 ${parsedNodes.length} 个节点数据`);
                    }
                    
                    appState.graph = routePlanner.buildGraph(appState.lines);
                    
                    console.log('静默加载应用状态更新完成:', {
                        stations: appState.stations.length,
                        lines: appState.lines.length,
                        graph: appState.graph ? '已构建' : '未构建'
                    });
                    
                    // 更新UI
                    mapRenderer.clearMap();
                    mapRenderer.render();
                    
                    // 设置地图中心为旧园站
                    const jiuyuanStation = appState.stations.find(station => station.name === '旧园');
                    if (jiuyuanStation) {
                        // 计算旧园站的屏幕坐标
                        const screenPos = mapRenderer.worldToScreen(jiuyuanStation.X, jiuyuanStation.Y);
                        const canvasCenterX = appState.canvas.width / 2;
                        const canvasCenterY = appState.canvas.height / 2;
                        
                        // 设置地图偏移量，使旧园站位于屏幕中心
                        appState.mapOffset.x = canvasCenterX - screenPos.x;
                        appState.mapOffset.y = canvasCenterY - screenPos.y;
                        
                        // 重新渲染地图
                        mapRenderer.render();
                    }
                    
                    // 更新站点选择下拉菜单
                    this.updateStationSelects();
                    
                    // 初始化可搜索下拉框
                    if (typeof this.initSearchableSelects === 'function') {
                        this.initSearchableSelects();
                    }
                    
                    console.log('subway-data.js数据静默加载完成');
                    
                } catch (error) {
                    console.error('数据静默加载错误:', error);
                }
            },

            autoCalculateRoute() {
                const startStation = document.getElementById('startStation').value;
                const endStation = document.getElementById('endStation').value;
                
                // 只有当起点和终点都已选择时才自动计算路径
                if (startStation && endStation && startStation !== endStation) {
                    this.handleRouteCalculation();
                }
            },

            handleRouteCalculation() {
                const startStation = document.getElementById('startStation').value;
                const endStation = document.getElementById('endStation').value;
                
                if (!startStation || !endStation) {
                    utils.showNotification('请选择起点和终点站', 'error');
                    return;
                }
                
                if (startStation === endStation) {
                    utils.showNotification('起点和终点不能相同', 'error');
                    return;
                }
                
                if (!appState.graph) {
                    utils.showNotification('请先导入线路数据', 'error');
                    return;
                }
                
                try {
                    // 计算路径
                    const route = routePlanner.dijkstra(appState.graph, startStation, endStation);
                    
                    if (route.distance === Infinity) {
                        utils.showNotification('无法找到从起点到终点的路径', 'error');
                        return;
                    }
                    
                    // 分析换乘信息
                    const transfers = routePlanner.analyzeTransfers(route, appState.lines);
                    
                    // 显示路线
                    mapRenderer.displayRoute(route, transfers);
                    
                    // 更新UI信息
                    const routeInfo = document.getElementById('routeInfo');
                    routeInfo.innerHTML = `
                        <p><strong>路径规划完成</strong></p>
                        <p>途经站点: <span class="highlight">${route.path.length}</span> 个</p>
                        <p>换乘次数: <span class="highlight">${transfers.length - 1}</span> 次</p>
                    `;
                    
                    // 更新换乘信息
                    const transferInfo = document.getElementById('transferInfo');
                    transferInfo.innerHTML = transfers.map((transfer, index) => {
                        // 查找线路信息，判断是否为步行路线路
                        const lineInfo = appState.lines.find(line => line.name === transfer.lineName || line.id === transfer.line);
                        const isWalkingLine = lineInfo && lineInfo.lineType === 'walking';
                        
                        // 如果是步行路线路，完全不显示在换乘信息框中
                        if (isWalkingLine) {
                            return '';
                        } else {
                            return `
                                <div class="transfer-step">
                                    <div class="line-name">
                                        换乘线路：${transfer.lineName}
                                    </div>
                                    <div class="stations">
                                        ${transfer.stations.join(' → ')}
                                    </div>
                                </div>
                            `;
                        }
                    }).join('');
                    
                    utils.showNotification(`路径规划完成`);
                    
                } catch (error) {
                    utils.showNotification('路径计算错误', 'error');
                    console.error('路径计算错误:', error);
                }
            },

            handleZoomIn() {
                appState.mapScale = Math.min(3, appState.mapScale * 1.2);
                mapRenderer.render();
            },

            handleZoomOut() {
                appState.mapScale = Math.max(0.5, appState.mapScale * 0.8);
                mapRenderer.render();
            },

            handleResetView() {
                appState.mapScale = 1;
                appState.mapOffset = { x: 0, y: 0 };
                mapRenderer.render();
            },

            handleSaveImage() {
                try {
                    // 保存当前的地图状态
                    const originalScale = appState.mapScale;
                    const originalOffset = { ...appState.mapOffset };
                    
                    // 动态计算完整地图的范围
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    
                    if (appState.stations && appState.stations.length > 0) {
                        appState.stations.forEach(station => {
                            if (station.X !== undefined && station.Y !== undefined) {
                                minX = Math.min(minX, station.X);
                                maxX = Math.max(maxX, station.X);
                                minY = Math.min(minY, station.Y);
                                maxY = Math.max(maxY, station.Y);
                            }
                        });
                    }
                    
                    // 如果没有有效数据，使用默认范围（这个范围改不得）
                    if (minX === Infinity) {
                        minX = -1000; maxX = 1000;
                        minY = -1000; maxY = 1000;
                    }
                    
                    // 设置合适的缩放比例以显示完整地图
                    const targetScale = 0.8; // 调整这个值以获得最佳显示效果
                    
                    // 创建临时Canvas来渲染完整地图
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // 设置临时Canvas尺寸，确保完整地图能够显示
                    const scale = 2; // 与worldToScreen中的scale一致
                    const offsetX = 400; // 与worldToScreen中的offsetX一致
                    const offsetY = -100; // 与worldToScreen中的offsetY一致
                    
                    // 计算所需Canvas尺寸，确保能容纳完整地图
                    const margin = 100; // 边距
                    
                    // 关键修复：正确计算地图的实际显示范围
                    // 根据worldToScreen公式：screenX = centerX + (x + offsetX) * scale * mapScale + mapOffset.x
                    // 当centerX = canvas.width/2，mapOffset.x = 0时，地图的实际显示范围是：
                    // 从 -centerX 到 +centerX，而不是从0开始
                    
                    // 计算地图在转换后的坐标系中的最大范围
                    const maxAbsX = Math.max(Math.abs(minX + offsetX), Math.abs(maxX + offsetX));
                    const maxAbsY = Math.max(Math.abs(minY + offsetY), Math.abs(maxY + offsetY));
                    
                    // 计算所需的Canvas尺寸（考虑中心点偏移后的完整范围）
                    const requiredWidth = maxAbsX * 2 * scale * targetScale + margin * 2;
                    const requiredHeight = maxAbsY * 2 * scale * targetScale + margin * 2;
                    
                    // 使用高分辨率以获得更清晰的图片
                    const resolutionMultiplier = 3; // 提高分辨率倍数
                    tempCanvas.width = Math.max(3000, requiredWidth * resolutionMultiplier);
                    tempCanvas.height = Math.max(2250, requiredHeight * resolutionMultiplier);
                    
                    // 设置临时Canvas的上下文
                    tempCtx.fillStyle = '#ffffff';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // 临时修改appState以渲染到临时Canvas
                    const originalCanvas = appState.canvas;
                    const originalCtx = appState.ctx;
                    
                    appState.canvas = tempCanvas;
                    appState.ctx = tempCtx;
                    appState.mapScale = targetScale * resolutionMultiplier;
                    
                    // 计算中心点（Canvas的中心）
                    const centerX = tempCanvas.width / 2;
                    const centerY = tempCanvas.height / 2;
                    
                    // 关键修复：不需要额外的偏移，因为worldToScreen函数已经考虑了centerX和centerY
                    appState.mapOffset = { 
                        x: 0,
                        y: 0
                    };
                    
                    // 关键修复：临时修改worldToScreen函数，使其使用固定的中心点计算
                    const originalWorldToScreen = mapRenderer.worldToScreen;
                    mapRenderer.worldToScreen = function(x, y) {
                        const screenX = centerX + (x + offsetX) * scale * appState.mapScale + appState.mapOffset.x;
                        const screenY = centerY + (y + offsetY) * scale * appState.mapScale + appState.mapOffset.y;
                        return { x: screenX, y: screenY };
                    };
                    
                    // 重新渲染完整地图
                    mapRenderer.clearMap();
                    
                    // 在临时Canvas上设置白色背景
                    tempCtx.fillStyle = '#ffffff';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // 渲染所有线路和站点
                    if (appState.lines && appState.lines.length > 0) {
                        mapRenderer.displayLinesWithTurns(appState.lines);
                        mapRenderer.displayStations(appState.lines);
                        
                        // 在Canvas上绘制站点名字（用于图片保存）
                        this.drawStationNamesOnCanvas(appState.lines);
                    }
                    
                    // 在Canvas上绘制图例（用于图片保存）- 在渲染完成后单独绘制
                    if (appState.lines && appState.lines.length > 0) {
                        mapRenderer.drawLegendOnCanvas(tempCtx, targetScale * resolutionMultiplier);
                    }
                    
                    // 恢复原始状态
                    appState.canvas = originalCanvas;
                    appState.ctx = originalCtx;
                    appState.mapScale = originalScale;
                    appState.mapOffset = originalOffset;
                    
                    // 恢复原始的worldToScreen函数
                    mapRenderer.worldToScreen = originalWorldToScreen;
                    
                    // 重新渲染原始视图
                    mapRenderer.render();
                    
                    // 转换为DataURL
                    const dataURL = tempCanvas.toDataURL('image/png');
                    
                    // 创建下载链接
                    const link = document.createElement('a');
                    link.download = `Jiuyuantong_${new Date().toLocaleDateString().replace(/\//g, '-')}.png`;
                    link.href = dataURL;
                    
                    // 触发下载
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    utils.showNotification('完整地图图片已保存');
                } catch (error) {
                    console.error('保存图片失败:', error);
                    utils.showNotification('保存图片失败，请重试', 'error');
                }
            },
            
            drawStationNamesOnCanvas(lines) {
                const ctx = appState.ctx;
                const scale = appState.mapScale;
                
                lines.forEach(line => {
                    line.stations.forEach(station => {
                        const screenPos = mapRenderer.worldToScreen(station.X, station.Y);
                        
                        // 设置字体样式（在高分辨率下保持清晰）
                        ctx.font = `${Math.max(14, 16 * scale)}px Arial, sans-serif`;
                        ctx.fillStyle = '#000000';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // 绘制站点名字
                        ctx.fillText(station.name, screenPos.x, screenPos.y - 18 * scale);
                        
                        // 如果有英文名字，也绘制
                        if (station.englishName && station.englishName !== station.name) {
                            ctx.font = `${Math.max(12, 14 * scale)}px Arial, sans-serif`;
                            ctx.fillStyle = '#333333';
                            ctx.fillText(station.englishName, screenPos.x, screenPos.y + 18 * scale);
                        }
                    });
                });
            }
        };

        // 初始化应用
        document.addEventListener('DOMContentLoaded', function() {
            window.eventHandlers.init();
            
            // 设置默认光标样式
            appState.canvas.style.cursor = 'grab';
            
            // 初始渲染
            mapRenderer.render();
        });
    </script>
    
    <!-- 内嵌地铁数据 -->
    <script>
        // 地铁线路数据 - 以线路为中心的存储结构 
        const subwayData = `lineId,lineName,color,isExpress,stationSequence
K1,K1,#53c700,true,"旧园:1,纽克北站:2"
K2,K2,#005eff,true,"瑜西:1,新城口:2,大西洋鲑:3"

K99,K99(单向),#202000,true,"纽克北站:1,远西南·西要塞通道:2"


N1,N1,#E3002B,false,"纽克北站:1,工业园:2,纽克站:3,劫掠前哨:4,旧园郊:5,旧园:6,北桥:7,瑜西:8,北桥泰加:9"
N2,N2,#66ccff,false,"阿萨伟:1,热德块:2"
HCL线,HCL线,#bfa15c,false,"沙北站:1,府邸:2,阿萨伟:3"

Z1,Z1,#00c3ff,false,"十字口:1,新城口:2,渔场:3,旧园:4,峨巗口:5,友谊长存纪念碑:6,南江畔:7,大西洋鲑:8,劫掠前哨:9,南洲:10"
Z2,Z2,#00ffaa,false,"旧园郊:1,近东南一村:2"
Z3,Z3,#fcba77,false,"工业园:1,十字口:2,北桥泰加:3,沙北东站:4"
中潭纵通线,中潭纵通线,#225500,true,"东角机场:1,十字口:2,南洲:3"
中潭横通线,中潭横通线,#aadd00,true,"新城口:1,十字口:2,西坪:3"
东角环线,东角环线,#660000,false,"东角机场:1,东角大道北:2,新城口:3,十字口:4,东角机场:5"
`;

        // 站点坐标信息（单独存储）
        const stationCoordinates = `name,englishName,X,Y,transfer,transferLines,transferPlatforms,isMajor,management
旧园,Jiuyuan,-137,66,true,"K1,N1,Z1","3F,地下,2F",true,旧园
旧园郊,Jiuyuanjiao,-222,226,true,"N1,Z2","-1F,-2F",false,旧园
峨巗口,Eyankou,-60,66,false,,,false,旧园
友谊长存纪念碑,Monument to Eternal Friendship,-60,118,false,,,false,旧园
远西南·西要塞通道,Yuanxinan,-966,800,false,,,false,K99终点
渔场,Yuchang,-206,66,false,,,false,旧园

新城口,Xinchengkou,-238,16,true,"K2,Z1","2F,1F",true,中潭
十字口,Shizikou,-330,16,true,"Z1,Z3,东角环线,中潭纵通","无站台信息",true,中潭
沙北东站,Shabei East Station,-325,-490,false,,,false,
沙北站,Shabei Station,-522,-550,true,"HCL","",false,
南洲,Nanzhou,-330,66,true,"","",false,中潭（规划中，K1不停靠）
西坪,Xiping,-440,16,false,,,false,中潭（规划中）
东角机场,Dongjiao Airport,-330,-180,true,"东角环线,中潭纵通线","无站台信息",false,中潭（规划中）
东角大道北,Dongjiao Ave. N.,-258,-150,false,,,false,中潭（规划中）

工业园,Gongyeyuan,-814,255,true,"N1,Z3","A,B",false,纽克
纽克北站,Niuke North Station,-963,66,true,"K1,N1,K99","地上,地下,地下",false,纽克 K99起点
劫掠前哨,Jielueqianshao,-630,226,false,,,false,纽克
纽克站,Niuke Station,-814,333,true,"近西南线,N1","地上,地下",false,纽克
阿萨伟,Asawei,-900,-370,true,"HCL,N2","无站台信息",false,纽克
府邸,Fudi,-757,264,true,,,false,纽克
热德块,Redekuai,-900,-730,true,,,false,纽克

北桥,Beiqiao,-136,-224,false,,,false,北桥
北桥泰加,Beiqiao Taiga,-330,-224,true,"N1,Z1","无站台信息",false,北桥
瑜西,Yuxi,-238,-224,false,,,false,北桥

南江畔,Nanjiangpan,-60,226,true,"Z1,Z2","站台 2,站台 1",false,
近东南一村,Jindongnan I,125,226,false,,,false,

大西洋鲑,Daxiyanggui,-238,456,true,"K2,Z1","房前高架桥",false,大西洋鲑

`;
    </script>

    <!-- 内嵌步行路数据 -->
    <script>
        // 步行路数据 - 步行路线路类型 
        const walkingData = `color,isExpress,lineType,stationSequence
#808080,false,walking,"旧园郊(铁路):1,旧园郊(快船):2"
#808080,false,walking,"府邸:1,工业园:2"
#808080,false,walking,"北桥:1,瑜西:2,北桥泰加:3"
`;
    </script>
    <script>
        // 节点数据 x，y为坐标 line为线路id 节点在线路上的stn1和stn2两个站之间
        const nodeData = `x,y,line,stn1,stn2
        
`;
    </script>
</body>
</html>